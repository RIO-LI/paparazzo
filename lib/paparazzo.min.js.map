{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///paparazzo.min.js","webpack:///webpack/bootstrap 808b79e8f96ced2f2e72","webpack:///./src/paparazzo.ts","webpack:///./src/index.ts"],"names":["root","factory","exports","module","define","amd","a","i","this","modules","__webpack_require__","moduleId","installedModules","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","isObject","target","isFunction","Paparazzo","config","eventsMap","separator","assign","splitEventNames","eventName","names","split","map","trim","filter","length","addEventHandlers","handler","once","prepend","_this","forEach","handlers","Array","isArray","queue","fn","item","originHandler","args","_i","arguments","off","apply","concat","processEvents","process","on","eventsMap_1","once_1","prepend_1","keys","eventNames","prependListener","prependOnceListener","emit","payload","targetHandlers_1","targetHandler","size","slice","listeners","paparazzo_1"],"mappings":"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","file":"paparazzo.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 1);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar isObject = function (target) {\n    return typeof target === 'object' && target != null;\n};\nvar isFunction = function (target) {\n    return typeof target === 'function';\n};\nvar Paparazzo = (function () {\n    function Paparazzo(config) {\n        this.eventsMap = {};\n        this.config = {\n            separator: ' ',\n        };\n        if (isObject(config)) {\n            this.config = Object.assign(this.config, config);\n        }\n    }\n    Paparazzo.prototype.splitEventNames = function (eventName) {\n        var names = eventName.split(this.config.separator ? this.config.separator : ' ');\n        names = names.map(function (name) {\n            return name.trim();\n        }).filter(function (name) {\n            return (name.trim()).length > 0;\n        });\n        return names;\n    };\n    Paparazzo.prototype.addEventHandlers = function (eventName, handler, once, prepend) {\n        var _this = this;\n        if (!eventName) {\n            return this;\n        }\n        this.splitEventNames(eventName)\n            .forEach(function (name) {\n            if (!_this.eventsMap[name]) {\n                _this.eventsMap[name] = [];\n            }\n            var handlers = [];\n            if (!Array.isArray(handler)) {\n                handlers = [handler];\n            }\n            else {\n                handlers = handler;\n            }\n            var queue = handlers.filter(function (fn) { return isFunction(fn); }).map(function (fn) {\n                var item = {\n                    originHandler: fn,\n                    handler: fn,\n                };\n                if (once) {\n                    item.handler = function () {\n                        var args = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            args[_i] = arguments[_i];\n                        }\n                        _this.off(name, fn);\n                        fn.apply(void 0, args);\n                    };\n                }\n                return item;\n            });\n            if (prepend) {\n                _this.eventsMap[name] = queue.concat(_this.eventsMap[name]);\n            }\n            else {\n                _this.eventsMap[name] = (_this.eventsMap[name]).concat(queue);\n            }\n        });\n        return this;\n    };\n    Paparazzo.prototype.processEvents = function (eventName, process) {\n        var _this = this;\n        var args = [];\n        for (var _i = 2; _i < arguments.length; _i++) {\n            args[_i - 2] = arguments[_i];\n        }\n        this.splitEventNames(eventName)\n            .forEach(function (name) {\n            (_this.eventsMap[name] || []).forEach(function (handler) {\n                process.apply(void 0, [name, handler.handler].concat(args));\n            });\n        });\n        return this;\n    };\n    Paparazzo.prototype.on = function () {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (isObject(args[0])) {\n            var eventsMap_1 = args[0];\n            var once_1 = !!args[1];\n            var prepend_1 = !!args[2];\n            Object.keys(eventsMap_1).forEach(function (eventName) {\n                _this.addEventHandlers(eventName, eventsMap_1[eventName], once_1, prepend_1);\n            });\n        }\n        else {\n            var eventNames = args[0];\n            var handlers = args[1];\n            var once = !!args[2];\n            var prepend = !!args[3];\n            this.addEventHandlers(eventNames, handlers, once, prepend);\n        }\n        return this;\n    };\n    Paparazzo.prototype.prependListener = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this.on.call(this, args[0], args[1], args[2], true);\n        return this;\n    };\n    Paparazzo.prototype.prependOnceListener = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        return this.on.call(this, args[0], args[1], true, true);\n    };\n    Paparazzo.prototype.once = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        this.on.call(this, args[0], args[1], true, false);\n        return this;\n    };\n    Paparazzo.prototype.emit = function (eventName, payload) {\n        return this.processEvents(eventName, function (name, handler, payload) {\n            handler(payload);\n        }, payload);\n    };\n    Paparazzo.prototype.off = function (eventName, handler) {\n        var _this = this;\n        var eventsMap = (this.eventsMap[eventName] || []);\n        if (!handler) {\n            this.splitEventNames(eventName).forEach(function (name) {\n                delete _this.eventsMap[name];\n            });\n        }\n        else {\n            var targetHandlers_1 = Array.isArray(handler) ? handler : [handler];\n            this.splitEventNames(eventName).forEach(function (name) {\n                targetHandlers_1.forEach(function (targetHandler) {\n                    var size = eventsMap.length;\n                    for (var i = 0; i < size; i++) {\n                        if (eventsMap[i]['originHandler'] === targetHandler) {\n                            _this.eventsMap[name] = eventsMap = eventsMap.slice(0, i).concat(eventsMap.slice(i + 1));\n                            break;\n                        }\n                    }\n                });\n            });\n        }\n        return this;\n    };\n    Paparazzo.prototype.eventNames = function () {\n        return Object.keys(this.eventsMap);\n    };\n    Paparazzo.prototype.listeners = function (eventName) {\n        return (this.eventsMap[eventName] || []).map(function (item) { return item.originHandler; });\n    };\n    return Paparazzo;\n}());\nexports.Paparazzo = Paparazzo;\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar paparazzo_1 = __webpack_require__(0);\nexports.Paparazzo = paparazzo_1.Paparazzo;\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// paparazzo.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 1);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 808b79e8f96ced2f2e72","// 事件处理器类型\ntype EventHandler = (payload?: any) => void;\n\n// 事件哈希集合类型\ninterface IEventsMap {\n    [propName: string]: IEventMapItem[];\n}\n\ninterface IEventMapItem {\n    handler: EventHandler;\n    originHandler: EventHandler;\n    [propName: string]: any;\n}\n\ninterface IEventHandlersMap {\n    [propName: string]: EventHandler[] | EventHandler;\n}\n\n// Paparazzo实例对象配置类型\ninterface IConfig {\n    separator?: string; // 事件名分隔符\n    [propName: string]: any;\n}\n\n/**\n * 判断一个目标是否为对象类型\n * @param target 需要检测的目标对象\n * @returns boolean true表示是对象类型，false表示不是对象类型\n */\nconst isObject = (target: any): boolean => {\n    return typeof target === 'object' && target != null;\n};\n\n/**\n * 判断一个目标是否为函数类型\n * @param target 需要检测的目标对象\n * @returns boolean true表示是函数类型，false表示函数对象类型\n */\nconst isFunction = (target: any): boolean => {\n    return typeof target === 'function';\n};\n\nexport class Paparazzo {\n\n    // 存储事件处理器集合或事件处理器与事件名的map集合，\n    // key为事件名，value为事件处理器集合或事件处理器\n    private eventsMap: IEventsMap = {};\n\n    // 配置对象\n    private config: IConfig = {\n        separator: ' ', // 事件名分隔符\n    };\n\n    constructor(config?: IConfig) {\n        if (isObject(config)) {\n            this.config = (Object as any).assign(this.config, config);\n        }\n    }\n\n    /**\n     * 根据事件名风格符对事件名字符串进行切割，默认风格符为空格\n     * @param eventName 事件名\n     */\n    private splitEventNames(eventName: string): string[] {\n        let names: string[] = eventName.split(this.config.separator ? this.config.separator : ' ');\n        names = names.map((name: string) => {\n            return name.trim();\n        }).filter((name: string) => {\n            return (name.trim()).length > 0;\n        });\n        return names;\n    }\n\n    /**\n     * 为指定事件添加处理器\n     * @param eventName  事件名\n     * @param handler 事件处理器或处理器集合\n     * @param once 是否只监听一次，true 表示是，false表示不是，默认为false\n     * @param prepend 是否将处理器添加到该事件处理器队列的最前方，true 表示是，false表示不是，默认为false\n     */\n    private addEventHandlers(eventName: string, handler: EventHandler[] | EventHandler, once?: boolean, prepend?: boolean): Paparazzo {\n        if (!eventName) {\n            return this;\n        }\n        this.splitEventNames(eventName)\n            .forEach((name: string) => {\n                if (!this.eventsMap[name]) {\n                    this.eventsMap[name] = [];\n                }\n                let handlers: EventHandler[] = [];\n                if (!Array.isArray(handler)) {\n                    handlers = [handler];\n                } else {\n                    handlers = handler;\n                }\n                const queue = handlers.filter((fn) => isFunction(fn)).map((fn) => {\n                    const item = {\n                        originHandler: fn,\n                        handler: fn,\n                    };\n                    if (once) {\n                        item.handler = (...args: any[]) => {\n                            this.off(name, fn);\n                            fn(...args);\n                        };\n                    }\n                    return item;\n                });\n\n                if (prepend) {\n                    this.eventsMap[name] = queue.concat(this.eventsMap[name]);\n                } else {\n                    this.eventsMap[name] = (this.eventsMap[name]).concat(queue);\n                }\n            });\n        return this;\n    }\n\n    /**\n     * 对事件的处理器进行迭代处理\n     * @param eventName 事件名,如果需要对多个事件进行监听，可以用事件分隔符隔开，默认为空格\n     * @param process 迭代处理\n     * @param args 迭代处理器的入参\n     */\n    private processEvents(eventName: string, process: any, ...args: any[]): Paparazzo {\n        this.splitEventNames(eventName)\n            .forEach((name: string) => {\n                (this.eventsMap[name] || []).forEach((handler) => {\n                    process(name, handler.handler, ...args);\n                });\n            });\n        return this;\n    }\n\n    /**\n     * 对事件进行监听\n     * @param eventName 事件名,如果需要对多个事件进行监听，可以用事件分隔符隔开，默认为空格\n     * @param handlers 事件处理器或事件处理器集合\n     * @param once 是否只监听一次,true 表示是，false表示不是\n     * @param prepend 是否将处理器添加到该事件处理器队列的最前方，true 表示是，false表示不是，默认为false\n     */\n    public on(eventName: string, handlers: EventHandler[] | EventHandler, once?: boolean, prepend?: boolean): Paparazzo;\n\n    /**\n     * 对事件集合进行监听\n     * @param eventHandlersMap 事件集合对象，键为要监听的事件名，值为对应事件处理器\n     * @param once 是否只监听一次,true 表示是，false表示不是\n     * @param prepend 是否将处理器添加到该事件处理器队列的最前方，true 表示是，false表示不是，默认为false\n     */\n    public on(eventHandlersMap: IEventHandlersMap, once?: boolean, prepend?: boolean): Paparazzo;\n\n    /**\n     * 对指定事件进行监听\n     */\n    public on(...args: any[]): Paparazzo {\n        if (isObject(args[0])) {\n            const eventsMap: IEventHandlersMap = args[0];\n            const once: boolean = !!args[1];\n            const prepend: boolean = !!args[2];\n            Object.keys(eventsMap).forEach((eventName: string) => {\n                this.addEventHandlers(eventName, eventsMap[eventName], once, prepend);\n            });\n        } else {\n            const eventNames: string = args[0];\n            const handlers: EventHandler[] | EventHandler = args[1];\n            const once: boolean = !!args[2];\n            const prepend: boolean = !!args[3];\n            this.addEventHandlers(eventNames, handlers, once, prepend);\n        }\n        return this;\n    }\n\n    /**\n     * 对事件进行监听，并将处理器添加到该事件处理器队列的最前方\n     * @param eventName 事件名,如果需要对多个事件进行监听，可以用事件分隔符隔开，默认为空格\n     * @param handlers 事件处理器或事件处理器集合\n     * @param once 是否只监听一次\n     */\n    public prependListener(eventName: string, handlers: EventHandler[] | EventHandler, once?: boolean): Paparazzo;\n\n    /**\n     * 对事件进行监听，并将处理器添加到该事件处理器队列的最前方\n     * @param eventHandlersMap 事件集合对象，键为要监听的事件名，值为对应事件处理器\n     * @param once 是否只监听一次\n     */\n    public prependListener(eventHandlersMap: IEventHandlersMap, once?: boolean): Paparazzo;\n\n    /**\n     * 对事件进行监听，并将处理器添加到该事件处理器队列的最前方\n     */\n    public prependListener(...args: any[]): Paparazzo {\n        this.on.call(this, args[0], args[1], args[2], true);\n        return this;\n    }\n\n    /**\n     * 对事件进行一次性监听，并将处理器添加到该事件处理器队列的最前方\n     * @param eventName 事件名,如果需要对多个事件进行监听，可以用事件分隔符隔开，默认为空格\n     * @param handlers 事件处理器或事件处理器集合\n     */\n    public prependOnceListener(eventName: string, handlers: EventHandler[] | EventHandler): Paparazzo;\n\n    /**\n     * 对事件进行一次性监听，并将处理器添加到该事件处理器队列的最前方\n     * @param eventHandlersMap 事件集合对象，键为要监听的事件名，值为对应事件处理器\n     */\n    public prependOnceListener(eventHandlersMap: IEventHandlersMap): Paparazzo;\n\n    /**\n     * 对事件进行一次性监听，并将处理器添加到该事件处理器队列的最前方\n     */\n    public prependOnceListener(...args: any[]): Paparazzo {\n        return this.on.call(this, args[0], args[1], true, true);\n    }\n\n    /**\n     * 对事件进行监听\n     * @param eventName 事件名,如果需要对多个事件进行监听，可以用事件分隔符隔开，默认为空格\n     * @param handlers 事件处理器或事件处理器集合\n     */\n    public once(eventName: string, handlers: EventHandler[] | EventHandler): Paparazzo;\n\n    /**\n     * 对事件集合进行监听\n     * @param eventHandlersMap 事件集合对象，键为要监听的事件名，值为对应事件处理器\n     */\n    public once(eventHandlersMap: IEventHandlersMap): Paparazzo;\n\n    /**\n     * 对指定事件进行一次性监听，当事件触发后，事件将从事件处理中移除\n     */\n    public once(...args: any[]): Paparazzo {\n        this.on.call(this, args[0], args[1], true, false);\n        return this;\n    }\n\n    /**\n     * 触发指定事件并发送相关数据\n     * @param eventName 事件名，如果需要对多个事件进行触发时，可以用事件分隔符隔开，默认为空格\n     * @param payload 事件需要处理的数据\n     */\n    public emit(eventName: string, payload?: any): Paparazzo {\n        return this.processEvents(eventName, (name: string, handler: EventHandler, payload: any) => {\n            handler(payload);\n        }, payload);\n    }\n\n    /**\n     * 对指定事件进行移除\n     * @param eventName 事件名，如果需要对多个事件名进行触发时，可以用事件分隔符隔开，默认为空格\n     * @param handler 需要移除的处理器集合或处理器\n     */\n    public off(eventName: string, handler?: EventHandler[] | EventHandler): Paparazzo {\n        let eventsMap: IEventMapItem[] = (this.eventsMap[eventName] || []);\n        if (!handler) {\n            this.splitEventNames(eventName).forEach((name: string) => {\n                delete this.eventsMap[name];\n            });\n        } else {\n            const targetHandlers = Array.isArray(handler) ? handler : [handler];\n            this.splitEventNames(eventName).forEach((name: string) => {\n                targetHandlers.forEach((targetHandler) => {\n                    const size = eventsMap.length;\n                    for (let i = 0; i < size; i++) {\n                        if (eventsMap[i]['originHandler'] === targetHandler) {\n                            this.eventsMap[name] = eventsMap = eventsMap.slice(0, i).concat(eventsMap.slice(i + 1));\n                            break;\n                        }\n                    }\n                });\n            });\n        }\n        return this;\n    }\n\n    /**\n     * 获取全部监听的事件名\n     */\n    public eventNames(): string[] {\n        return Object.keys(this.eventsMap);\n    }\n\n    /**\n     * 获取指定事件名的处理器集合\n     * @param eventName 事件名\n     */\n    public listeners(eventName: string): EventHandler[] {\n        return (this.eventsMap[eventName] || []).map((item) => item.originHandler);\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader??ref--1!./src/paparazzo.ts","export { Paparazzo } from './paparazzo';\n\n\n\n// WEBPACK FOOTER //\n// ./~/tslint-loader??ref--1!./src/index.ts"],"sourceRoot":""}